"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebSocket = void 0;
const pako = __importStar(require("pako"));
const events_1 = require("events");
const ws_1 = require("ws");
const logger_1 = require("../logger");
class WebSocket extends events_1.EventEmitter {
    constructor() {
        super();
        this._untypedOn = this.on;
        this._untypedEmit = this.emit;
        this.on = (event, listener) => this._untypedOn(event, listener);
        this.emit = (event, ...args) => this._untypedEmit(event, ...args);
        this.isOpen = false;
        this.allowClose = false;
        this.failCount = 0;
        this.logger = new logger_1.Logger('WebSocket');
        this.logger.debug('正在初始化WebSocket...');
        process.env.NODE_TLS_REJECT_UNAUTHORIZED = '0';
        this.socket = new ws_1.WebSocket('wss://m2.iirose.com:8778');
        this.init();
        this.logger.debug('WebSocket初始化完成');
        setInterval(() => {
            if (this.isOpen)
                this.socket.send('');
        }, 30e3);
    }
    // 手动断开连接
    close() {
        this.allowClose = true;
        this.socket.close();
    }
    // 手动连接
    connect() {
        this.socket = new ws_1.WebSocket('wss://m2.iirose.com:8778');
        this.init();
    }
    // 初始化
    init() {
        this.allowClose = false;
        this.socket.onopen = this.handleOpen.bind(this);
        this.socket.onclose = this.handleClose.bind(this);
        this.socket.onmessage = this.handleMessage.bind(this);
        this.socket.onerror = this.handleError.bind(this);
    }
    // 连接成功
    handleOpen() {
        this.isOpen = true;
        this.emit('open');
        this.logger.info('WebSocket连接成功');
        this.failCount = 0;
    }
    // 连接关闭
    handleClose() {
        this.isOpen = false;
        this.emit('close');
        this.logger.warn('WebSocket连接已关闭');
        if (this.allowClose)
            return;
        this.logger.warn('正在重连WebSocket...');
        this.socket = new ws_1.WebSocket('wss://m2.iirose.com:8778');
        this.init();
    }
    // 消息处理
    handleMessage(event) {
        const array = new Uint8Array(event.data);
        const isCompressed = array[0] === 1;
        const data = isCompressed ? pako.inflate(array.slice(1), { to: 'string' }) : Buffer.from(array).toString();
        this.logger.debug(`Received(${data.length} bytes): ${data.length > 100 ? data.slice(0, 100) + '...' : data}`);
        this.emit('message', data);
    }
    // 错误处理
    handleError(error) {
        this.emit('error', error);
        this.close();
        this.failCount++;
        if (this.failCount > 5) {
            this.logger.fatal('WebSocket多次连接失败，程序退出');
            process.exit(1);
        }
        this.connect();
    }
    /**
     * @description 发送消息
     * @param data 消息内容
     */
    send(data) {
        if (this.isOpen) {
            const deflatedData = pako.gzip(data);
            const deflatedArray = new Uint8Array(deflatedData.length + 1);
            deflatedArray[0] = 1;
            deflatedArray.set(deflatedData, 1);
            return new Promise((resolve, reject) => {
                this.socket.send(deflatedArray, (err) => {
                    if (err)
                        return reject(err);
                    resolve(undefined);
                });
            });
        }
        throw new Error('WebSocket is not open');
    }
}
exports.WebSocket = WebSocket;
//# sourceMappingURL=index.js.map